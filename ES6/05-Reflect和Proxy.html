<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script type="text/javascript">
      //Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。
      // Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。
      //它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。


// get 实例方法 get(target, propKey, receiver)
      // let exam ={
      //     name: "Tom",
      //     age: 24
      // }
      // let proxy = new Proxy(exam, {
      //   get(target, propKey, receiver) {
      //     console.log('Getting ' + propKey);
      //     console.log(receiver);
      //     // receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身。
      //
      //     console.log(receiver === proxy); //true
      //     return target[propKey];
      //   }
      // })
      // console.log(proxy.age);

//get() 方法可以继承
      // let proxy = new Proxy({}, {
      //   get(target, propKey, receiver) {
      //       // 实现私有属性读取保护
      //       if(propKey[0] === '_'){
      //           throw new Erro(`Invalid attempt to get private     "${propKey}"`);
      //       }
      //       console.log('Getting ' + propKey);
      //       return target[propKey];
      //   }
      // });
      //
      // let obj = Object.create(proxy);
      // obj.name

//set(target, propKey, value, receiver)
      // let validator = {
      // set: function(obj, prop, value) {
      //         if (prop === 'age') {
      //             if (!Number.isInteger(value)) {
      //                 throw new TypeError('The age is not an integer');
      //             }
      //             if (value > 200) {
      //                 throw new RangeError('The age seems invalid');
      //             }
      //         }
      //         // 对于满足条件的 age 属性以及其他属性，直接保存
      //         obj[prop] = value;
      //     }
      // };
      // let proxy= new Proxy({}, validator)
      // proxy.age = 100;
      // proxy.age           // 100
      // proxy.age = 'oppps' // 报错
      // proxy.age = 300     // 报错

// apply(target, ctx, args)
// 用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。
      // function sub(a, b){
      //     return a - b;
      // }
      // let handler = {
      //     apply: function(target, ctx, args){
      //         console.log('handle apply');
      //         return Reflect.apply(...arguments);
      //     }
      // }
      // let proxy = new Proxy(sub, handler)
      // proxy(2, 1)

//has(target, propKey) 用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。

      // let  handler = {
      // has: function(target, propKey){
      //   console.log("handle has");
      //   return propKey in target;
      // }
      // }
      // let exam = {name: "Tom"}
      // let proxy = new Proxy(exam, handler)
      // 'name' in proxy


// construct(target, args) 用于拦截 new 命令。返回值必须为对象。
      // let handler = {
      //   construct: function (target, args, newTarget) {
      //     console.log('handle construct')
      //     return Reflect.construct(target, args, newTarget)
      //   }
      // }
      // class Exam {
      //   constructor (name) {
      //     this.name = name
      //   }
      // }
      // let ExamProxy = new Proxy(Exam, handler)
      // let proxyObj = new ExamProxy('Tom')
      // console.log(proxyObj)

//......学不下去了 好复杂
//更多请见： https://www.runoob.com/w3cnote/es6-reflect-proxy.html


    </script>
  </body>
</html>
